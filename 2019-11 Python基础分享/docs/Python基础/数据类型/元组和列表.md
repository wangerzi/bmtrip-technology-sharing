# 元组和列表

元组和列表虽然都是顺序存储，但是两者使用场景和存储策略等均有比较细微的区别，具体如下

### 列表(List)

列表是顺序存储结构『数组』在Python中的实现；列表写在方括号之间，每个元素用逗号隔开；可以被索引和切片，List还可以用 `+` 或者 `*` 操作符进行拼接，**列表中每个元素可修改**。

```python
arr = [1, 2, 'Hello']
print(arr[2]) # Hello
arr2 = arr * 2
print(arr2) # [1, 2, 'Hello', 1, 2, 'Hello']j
```

#### Python是如何存储的？

列表是一个动态的数组，元素可变可改，可以追加删除（append,resize）等；

- 当创建一个长度为 N 的列表，那么会分配一块长度为 N 个元素的内存
- 如果给新增的数组，追加元素，之前创建的长度为N的内存就不够用了，就会触发**扩容逻辑**。
  - 扩容时，首先申请分配 N + M 个元素，因为考虑到追加第一个元素可能是追加更多元素的开始
  - M = (N >> 3) + (N < ( ? 3 : 6)) + 1
  - 申请完新空间后，将老的列表数据存入进去，追加操作即追加到列表数据尾部

![数组存储](../../../../2019-11%20Python%E5%9F%BA%E7%A1%80%E5%88%86%E4%BA%AB/docs/Python%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/assets/20190524191747447.png)

#### 验证如下

```python
>>> import sys
>>> b = []
>>> sys.getsizeof(b)
64
>>> b.append(1)
>>> sys.getsizeof(b)
96
>>> b.append(2)
>>> b.append(3)
>>> b.append(4)
>>> sys.getsizeof(b)
96
>>> b.append(5)
>>> sys.getsizeof(b)
128
```

#### 操作大数组时避免多次扩容的方法

可以使用 `extend()` 方法

```python
>>> b = [1, 2, 3, 4]
>>> sys.getsizeof(b)
96
>>> b.extend([1, 2, 3, 4, 5, 6, 7, 8, 9, 0])
>>> sys.getsizeof(b)
232
```

#### 常见操作

##### 按照索引取值及修改

```python
a = [1, 2, 3]
print(a[0]) # 1
print(a[-1]) # 3
a[0] = -1
print(a) # [-1, 2, 3]
```

##### 获取元组长度

```python
a = [1, 2, 3]
print(len(a)) # 3
```

##### 成员运算符 in or not in

```python
a = [1, 2, 3]
print(1 in a) # True
print(4 not in a) # False
```

##### 切片操作

比较常用的截取数组数据的方法

```python
a = [1, 2, 3, 4]
print(a[1:]) # [2, 3, 4] 有头无尾，到最后
print(a[:-2]) # [1, 2, 3] 无头有尾，始于头
print(a[1:-1:2]) # [2, 4] 步长表示每次增加的值
```

##### 追加操作

```python
a = [1, 2, 3]
a.append(4)
print(a) # [1, 2, 3, 4]
# 批量追加
b = [1, 2]
b.extend([3, 4])
print(b) # [1, 2, 3, 4]
```

##### 插入元素

```python
a = [1, 2, 3]
a.insert(0, -1)
print(a) # [-1, 1, 2, 3]
```

##### 删除元素

```python
# 按索引删除
a = [1, 2, 3]
del a[0]
print(a) # [2, 3]

# 按值删除
b = [1, 2, 3]
b.remove(1)
print(b) # [2, 3]
```

##### 清空列表

```python
a = [1, 2, 3]
a.clear()
print(a) # []
```

##### 列表反向

```python
a = [1, 2, 3]
a.reverse()
print(a) # [3, 2, 1]
```

##### 弹出末尾元素

这个操作还有个名词，出栈

```python
a = [1, 2, 3]
num = a.pop()
print(num, a) # 3 [1, 2]
```

##### 弹出队首元素

还有个名词，出队

```python
a = [1, 2, 3]
a.pop(0)
print(num, a) # 1 [2, 3]
```

##### 排序

函数原型是 list.sort(cmp=None, key=None, reverse=False)

>  cmp 表示比较的回调函数
>
> key 表示取列表元素，默认是当前值
>
> reverse 表示是否逆序，默认否

```python
a = [1, 2, 3]
a.sort(reverse=True)
print(a) # [3, 2, 1]
```



### 元组(Tuple)

与列表相似，但是元组的**元素不能修改**

```python
tup = (1, 2, 3)
print(tup[0]) # 1
tup[0] = 123 # 非法操作，报错
```

#### 系统如何存储？

元组的长度和其中元素都不可变，存储方式与数组类似，均为连续分配内存；并且系统针对这个特性在存储方面做了一些优化；

- 资源缓存机制，当元组被移除掉的时候，并不会立马回收内存，而是下一次新增元组时，复用那一块内存
  - 比如一个长度为3的元组，使用完毕删掉之后，并不会立马回收；下次再有长度为3的元组，无论数据内容是否一致，均会复用那一块内存空间。
- 元组是不可变类型，但是多个元组可以合并为一个新元组，这里与列表不同，每次执行此操作都会分配新内存，并将多个元组合并在一起。

##### 验证如下

```python
>>> a = (1,2,3)
>>> id(a)
139632574583648
>>> del a
>>> b = (2, 3, 4)
>>> id(b)
139632574583648
```

#### 常见操作

##### 按照索引取值

```python
a = (1, 2 3)
print(a[0]) # 1
```

##### 获取元组长度

```python
a = (1, 2, 3)
print(len(a)) # 3
```

##### 成员运算符 in or not in

```python
a = (1, 2, 3)
print(1 in a) # True
print(4 not in a) # False
```

##### 切片

与数组中的切片含义一致

```python
a = (1, 2, 3, 4)
print(a[:-1]) # (1, 2, 3)
```
