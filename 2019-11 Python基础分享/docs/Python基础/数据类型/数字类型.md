# 数字类型(Number)

包括整形、布尔型、浮点数、复数等

```python
a = 1
b = True
c = 1.23 # c = 3E-2 => c = 0.03
d = 1 + 2j # 的= 1.1 + 2.2j
```

### 整数类型

#### 小型整数

对于小型的整数，[-5, 257)，Python中有一个整数池，不会重复开辟空间，验证如下：

```python
a = 1
b = 1
print(id(a), id(b)) # 94699833979328 94699833979328
```

#### 长整数

每个长整数都是新分配的，而且Python3的整数值不受位数限制，并且小型整数和长整数，类型都是 `<type 'int'>`，验证如下：

```python
>>> a = 123123123123123
>>> b = 123123123123123
>>> id(a)
139632552075088
>>> id(b)
139632552074928
>>>type(b)
<type 'int'>
```

#### 如何存储在内存中的

计算机的内存最小存储单位为 『位(bit)』，每一位能存放一个二进制（0/1），八个位称为一个『字节(Byte)』

整数就是存放在这连续的存储单位中的，假设我们现在有**一个字节(8位)用来存放整数**，现有整数和其在内存中的存储如下：

| 整数 | 内存中表示 |
| ---- | ---------- |
| 1    | 00000001   |
| 2    | 00000010   |
| 3    | 00000011   |
| 4    | 00000100   |
| 5    | 00000101   |
| 6    | 00000110   |

正整数在存储的时候，将十进制数转换为二进制存储即可，读取的时候再从二进制转化为十进制

那么问题来了，正整数可以通过转换为同等值的二进制来存储，负整数又怎么存储呢？

这里涉及到一个概念叫『补码』，其中定义了负整数的存储方法为 『取其无符号的整数部分，转换为二进制后，按位取反后加一』

所以 `-1` 的补码可由此推算：其正整数二进制表示为`00000001`，每一位都取反 `11111110`，加一后得到 `11111111`

| 负整数 | 无符号的整数部分 | 取反加一  |
| ------ | ---------------- | --------- |
| -1     | 00000001         | 1111 1111 |
| -2     | 00000010         | 1111 1110 |
| -3     | 00000011         | 1111 1101 |
| -4     | 00000100         | 1111 1100 |
| -5     | 00000101         | 1111 1011 |
| -6     | 00000110         | 1111 1010 |

### 浮点数

浮点数就是带小数点的数，在Python中，浮点数和整数的定义和存储方式是不一样的，如下：

```python
>>> print(type(1.1))
<class 'float'>
>>> print(type(1))
<class 'int'>
```

浮点数的比较并不精确，这是写程序还有测试的时候需要注意的一个地方，比如：

```python
print(0.1 + 0.2 == 0.3) # False
print(0.1 + 0.2) # 0.30000000000000004
```

为何会产生这个问题，还得从存储原理说起

#### 浮点数的存储原理