# 数字类型(Number)

包括整形、布尔型、浮点数、复数等

```python
a = 1
b = True
c = 1.23 # c = 3E-2 => c = 0.03
d = 1 + 2j # 的= 1.1 + 2.2j
```

### 整数类型

#### 小型整数

对于小型的整数，[-5, 257)，Python中有一个整数池，不会重复开辟空间，验证如下：

```python
a = 1
b = 1
print(id(a), id(b)) # 94699833979328 94699833979328
```

#### 长整数

每个长整数都是新分配的，而且Python3的整数值不受位数限制，并且小型整数和长整数，类型都是 `<type 'int'>`，验证如下：

```python
>>> a = 123123123123123
>>> b = 123123123123123
>>> id(a)
139632552075088
>>> id(b)
139632552074928
>>>type(b)
<type 'int'>
```

#### 如何存储在内存中的

计算机的内存最小存储单位为 『位(bit)』，每一位能存放一个二进制（0/1），八个位称为一个『字节(Byte)』

整数就是存放在这连续的存储单位中的，假设我们现在有**一个字节(8位)用来存放整数**，现有整数和其在内存中的存储如下：

| 整数 | 内存中表示 |
| ---- | ---------- |
| 1    | 00000001   |
| 2    | 00000010   |
| 3    | 00000011   |
| 4    | 00000100   |
| 5    | 00000101   |
| 6    | 00000110   |

正整数在存储的时候，将十进制数转换为二进制存储即可，读取的时候再从二进制转化为十进制

那么问题来了，正整数可以通过转换为同等值的二进制来存储，负整数又怎么存储呢？

这里涉及到一个概念叫『补码』，其中定义了负整数的存储方法为 『取其无符号的整数部分，转换为二进制后，按位取反后加一』

所以 `-1` 的补码可由此推算：其正整数二进制表示为`00000001`，每一位都取反 `11111110`，加一后得到 `11111111`

| 负整数 | 无符号的整数部分 | 取反加一  |
| ------ | ---------------- | --------- |
| -1     | 00000001         | 1111 1111 |
| -2     | 00000010         | 1111 1110 |
| -3     | 00000011         | 1111 1101 |
| -4     | 00000100         | 1111 1100 |
| -5     | 00000101         | 1111 1011 |
| -6     | 00000110         | 1111 1010 |

### 浮点数

浮点数就是带小数点的数，在Python中，浮点数和整数的定义和存储方式是不一样的，如下：

```python
>>> print(type(1.1))
<class 'float'>
>>> print(type(1))
<class 'int'>
```

浮点数的比较并不精确，这是写程序还有测试的时候需要注意的一个地方，比如：

```python
print(0.1 + 0.2 == 0.3) # False
print(0.1 + 0.2) # 0.30000000000000004
```

为何会产生这个问题，还得从浮点数在计算机中的存储原理说起

#### 浮点数的存储原理

二进制小数和二进制整数没有什么区别，都是0和1，但是中间多了一个点；

比如二进制小数 `101.101`，其十进制为 整数部分 + 小数部分

> 101.101 = 1 * $2^2$ + 0 * $2^1$ + 1 * $2^0$ + 1 * $2 ^{-1}$ + 0 * $2^{-2}$ + 1 * $2^{-3}$
>
> ​	       = 4 + 1 + 1/2 + 1/8
>
> ​	       = 5 + 0.5 + 0.125
>
> ​	       = 5.625

上面是读取二进制转为十进制的方法，接下来是十进制转换为二进制的方法，**乘2取整法**；

- 小数点钱的整数按照十进制转二进制的方式操作
- 小数部分乘2，取整数 0/1，剩下小数继续乘2，取整数 0/1，直到小数部分为0，或者达到制定的精度

比如十进制 `5.20` ，整数部分 5 的二进制表示为 `0000 0101`，小数部分 `0.20` 进行乘2取整操作，捋下来即可

> 0.20 * 2  = 0.4 => 0
>
> 0.40 * 2 = 0.8  => 0
>
> 0.80 * 2 = 1.6 => 1
>
> 0.60 * 2 = 1.2 => 1
>
> 
>
> 0.20 * 2 = 0.4 =>0
>
> 0.40 * 2 = 0.8  => 0
>
> ...循环往复

假设浮点数精度是 16 位，则 `5.20` 的小数表示就是 `0000 0101.0011 0011 0011 0011`，但是计算机内存中只有 0/1 对应低电平和高电平，没有额外的位表示小数点；

所以国际上有一个统一的存储规定 IEEE 753，针对32位和64位浮点数有如下规定，第一位是符号位，中间位是科学计数法的指数位（需要减去127），后边是实际存储数据的地方，比如 `5.20`  的小数表示 `0000 0101.0011 0011 0011 0011`，在32位中的实际存储中就是 `0|100 0000 1|000 0101 0011 0011 0011 0011`

有一个在线转换网站可以了解下：[<https://babbage.cs.qc.cuny.edu/IEEE-754.old/Decimal.html>](https://babbage.cs.qc.cuny.edu/IEEE-754.old/Decimal.html)

![img](assets/17885815-3fc87d048fa7824f)

![img](assets/17885815-617619cda363d7fd)

#### 如何避免浮点数对比天坑？

根据上方描述，了解到了 Python 的浮点数精度问题可能导致一定程度的误差，但是都比较小；

##### 方法1：差值小于某数均认为相等

```python
print(abs(a - b) <= allow_error) # allow_error = 1e-6 
```

##### 方法2：能用整数对比的就用整数

比如说余额最多到分，对比 0.3 和 0.1 + 0.3 可以通过 * 100 的方式直接对比整数

```python
print(int(a * 100) == int(b * 100))
```

>  在 Python3 中的 `math` 模块有一个 `isclose(a, b, rel_tol = 1e-09, abs_tol=0.0)` 函数，可以用于比较两个浮点数是否相等

### 布尔值

布尔值只有两个 真(True)、假(False)，布尔值的实质是整形，在内存中表示为 `1` 和 `0`

布尔值可以配合逻辑运算符，通过 `bool()` 函数将其他类型数据转换为布尔值