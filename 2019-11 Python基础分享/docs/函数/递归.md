# 递归

如果一个函数在内部调用自己，这个函数就是递归函数；为方便理解，可以看一下如下代码：

```python
def sumTotal(total = 100):
    if total == 1:
        return 1
    return total + sumTotal(total - 1)
sumTotal(5)
```

分析一下这个函数，当我执行 `sumTotal(5)` 时，相当于依次执行如下操作：

> sumTotal(5)
>
> => 5 + sumTotal(4)
>
> => 5 + 4 + sumTotal(3)
>
> => 5 + 4 + 3 + sumTotal(2)
>
> => 5 + 4 + 3 + 2 + sumTotal(1)
>
> => 5 + 4 + 3 + 2 + 1
>
> =>15

这就是一个典型的递归行为，在函数内部调用自身，这个函数的含义是：

计算 `1到total 之和 = total + 1到(total -1)之和`，当 `total == 1` 时，求和自然为 `1`



递归有如下特性：

- 递归需要有边界条件，不能无限层调用（也称为递归出口）
- 需要有递归模式，大问题要被分解成小问题（也称为递归体）

## 汉诺塔问题

汉诺塔问题是递归函数的经典应用，它来自一个古老传说：

​	在世界刚被创建的时候有一座钻石宝塔A，其上有64个金蝶。所有碟子按从大到小的次序从塔底堆放至塔顶。紧挨着这座塔有另外两个钻石宝塔B和C。从世界创始之日起，波罗门的牧师就一直在试图把塔A上的碟子移动到C上去，其间借助于塔B的帮助。每次只能移动一个碟子，任何时候都不能把一个碟子放在比它小的碟子上面。当牧师们完成这个任务时，世界末日也就到了。 

对于汉诺塔问题的求解，可以通过以下3步实现： 
（1）将塔A上的n -1个碟子借助C塔先移动到B塔上； 
（2）把塔A上剩下的一个碟子移动到塔C上； 
（3）将n - 1个碟子从B塔借助塔A移动到塔C上。 
很显然，这是一个递归求解的过程，假设碟子数n=3时，汉诺塔问题的求解过程如下图所示：

![汉诺塔问题](assets/20150824202425669)

### 实现代码

```python
def hanoi(n, A, B, C):
	"""表示将n个碟子，从A借助B移动到C"""
	if n == 1:
		# A 通过 B 移动到 C，如果只有一个盘子，
		print("Move %s => %s"%(A, C))
	else:
		hanoi(n-1, A, C, B) # 将 A 上 N-1 个盘子，从 A 借助 C 移动到 B
		print("Move %s => %s"%(A, C)) # 将 A 上最后一个盘子，直接移动到 C
		hanoi(n-1, B, A, C) # 将 B 上 N-1 个盘子，从 B 借助 A 移动到 C
hanoi(64, "A塔", "B塔", "C塔")
```

